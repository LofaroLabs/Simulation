#!/usr/bin/env python
# /* -*-  indent-tabs-mode:t; tab-width: 8; c-basic-offset: 8  -*- */
# /*
# Copyright (c) 2013, Daniel M. Lofaro
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the author nor the names of its contributors may
#       be used to endorse or promote products derived from this software
#       without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# */


import termios, fcntl, sys, os #To allow for keyboard commands
import hubo_ach as ha
import ach
import sys
import time
from ctypes import *
from openhubo.deprecated import CloseLeftHand,CloseRightHand

# Open Hubo-Ach feed-forward and feed-back (reference and state) channels
s = ach.Channel(ha.HUBO_CHAN_STATE_NAME)
r = ach.Channel(ha.HUBO_CHAN_REF_NAME)
#s.flush()
#r.flush()

# feed-forward will now be refered to as "state"
state = ha.HUBO_STATE()

# feed-back will now be refered to as "ref"
ref = ha.HUBO_REF()

# Get the current feed-forward (state) 
[statuss, framesizes] = s.get(state, wait=False, last=False)

fd = sys.stdin.fileno()

oldterm = termios.tcgetattr(fd)
newattr = termios.tcgetattr(fd)
newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
termios.tcsetattr(fd, termios.TCSANOW, newattr)

oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)
LHP = 0;
LAP = 0;

RWP = 0;
RSP = 0;
RSR = 0;
RSY = 0;
REB = 0;
RHP = 0;
RAP = 0;
RHR = 0; 
RKN = 0; 
LKN = 0;
RAR = 0; 
RWR = 0;
RWY = 0;
RF1 = 0;
RF2 = 0;
RF3 = 0;
RF4 = 0;
RF5 = 0;

#Bend knees/lean forward a bit for stability
print "bending knees"
for i in range (0, 40):
    RHP = RHP-0.03;
    ref.ref[ha.RHP] = RHP;
    r.put(ref)
    LHP = LHP-0.03;
    ref.ref[ha.LHP] = LHP;
    r.put(ref)
    RKN = RKN+0.03;
    ref.ref[ha.RKN] = RKN;
    r.put(ref)
    LKN = LKN+0.03;
    ref.ref[ha.LKN] = LKN;
    r.put(ref)
    RAP = RAP-0.01;
    ref.ref[ha.RAP] = RAP;
    r.put(ref)
    LAP = LAP-0.01;
    ref.ref[ha.LAP] = LAP;
    r.put(ref)
    time.sleep(0.5)

try:
    while 1:
        try:
            c = sys.stdin.read(1); 
	    if c == 'a':
    		    RSP = RSP-0.1;
      		    ref.ref[ha.RSP] = RSP;
      		    r.put(ref)
    	    if c == 'z': 
      		    RSP = RSP+0.1;
      		    ref.ref[ha.RSP] = RSP;
      		    r.put(ref)
	    if c == 's':
    		    RSR = RSR-0.1;
      		    ref.ref[ha.RSR] = RSR;
      		    r.put(ref)
    	    if c == 'x': 
      		    RSR = RSR+0.1;
      		    ref.ref[ha.RSR] = RSR;
      		    r.put(ref)
	    if c == 'd':
    		    RSY = RSY-0.1;
      		    ref.ref[ha.RSY] = RSY;
      		    r.put(ref)
    	    if c == 'c': 
      		    RSY = RSY+0.1;
      		    ref.ref[ha.RSY] = RSY;
      		    r.put(ref)
	    if c == 'f':
    		    REB = REB-0.1;
      		    ref.ref[ha.REB] = REB;
      		    r.put(ref)
    	    if c == 'v': 
      		    REB = REB+0.1;
      		    ref.ref[ha.REB] = REB;
      		    r.put(ref)
	    if c == 'g':
    		    RWY = RWY-0.1;
      		    ref.ref[ha.RWY] = RWY;
      		    r.put(ref)
    	    if c == 'b': 
      		    RWY = RWY+0.1;
      		    ref.ref[ha.RWY] = RWY;
      		    r.put(ref)
	    #if c == 'h':
    		    RWP = RWP-0.1;
      		    ref.ref[ha.RWP] = RWP;
      		    r.put(ref)
    	    #if c == 'n': 
      		    RWP = RWP+0.1;
      		    ref.ref[ha.RWP] = RWP;
      		    r.put(ref)
	    if c == 'h':
    		    RHP = RHP-0.1;
      		    ref.ref[ha.RHP] = RHP;
      		    r.put(ref)
    	    if c == 'n': 
      		    RHP = RHP+0.1;
      		    ref.ref[ha.RHP] = RHP;
      		    r.put(ref)
	    if c == 'j':
    		    RAP = RAP-0.1;
      		    ref.ref[ha.RAP] = RAP;
      		    r.put(ref)
    	    if c == 'm': 
      		    RAP = RAP+0.1;
      		    ref.ref[ha.RAP] = RAP;
      		    r.put(ref)
	    if c == 'w':
    		    RHR = RHR-0.1;
      		    ref.ref[ha.RHR] = RHR;
      		    r.put(ref)
    	    if c == 'e': 
      		    RHR = RHR+0.1;
      		    ref.ref[ha.RHR] = RHR;
      		    r.put(ref)
	    if c == 'r':
    		    RKN = RKN-0.1;
      		    ref.ref[ha.RKN] = RKN;
      		    r.put(ref)
    	    if c == 't': 
      		    RKN = RKN+0.1;
      		    ref.ref[ha.RKN] = RKN;
      		    r.put(ref)
	    if c == 'y':
    		    RAR = RAR-0.1;
      		    ref.ref[ha.RAR] = RAR;
      		    r.put(ref)
    	    if c == 'u': 
      		    RAR = RAR+0.1;
      		    ref.ref[ha.RAR] = RAR;
      		    r.put(ref)
            #right hand
    	    if c == 'w': 
      		    RF1 = 1;
      		    ref.ref[ha.RF1] = RF1;
      		    r.put(ref)
    	    if c == 'e': 
      		    RF1 = 0;
      		    ref.ref[ha.RF1] = RF1;
      		    r.put(ref)
    	    if c == 'r': 
      		    RF1 = -1;
      		    ref.ref[ha.RF1] = RF1;
      		    r.put(ref)
    	    if c == 't': 
      		    RF2 = 1;
      		    ref.ref[ha.RF2] = RF2;
      		    r.put(ref)
    	    if c == 'y': 
      		    RF2 = 0;
      		    ref.ref[ha.RF2] = RF2;
      		    r.put(ref)
    	    if c == 'u': 
      		    RF2 = -1;
      		    ref.ref[ha.RF2] = RF2;
      		    r.put(ref)
    	    if c == 'i': 
      		    RF3 = 1;
      		    ref.ref[ha.RF3] = RF3;
      		    r.put(ref)
    	    if c == 'o': 
      		    RF3 = -1;
      		    ref.ref[ha.RF3] = RF3;
      		    r.put(ref)
    	    if c == 'p': 
      		    RF4 = 1;
      		    ref.ref[ha.RF4] = RF4;
      		    r.put(ref)
    	    if c == '[': 
      		    RF5 = 1;
      		    ref.ref[ha.RF5] = RF5;
      		    r.put(ref)


   	    if c == 'q':
    		    break
        except IOError: pass
finally:
    termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)

# Close the connection to the channels
r.close()
s.close()

